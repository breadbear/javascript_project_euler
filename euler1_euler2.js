/*

EULER # 1 PROBLEM: "If we list all the natural numbers below 10 that are multiples of 3 or 5,
we get 3, 5, 6, and 9. The sum of these multiples is 23. Find the sum of all multiples
of 3 or 5 below 1000."

NOTE: An ugly and stupidly inefficient solution? Of course!
Just dove straight into the problem without reading any hints, and tried to
 to solve it with the tools I had just learned about.

I originally approached the problem by making an array of all the multiples of 3
less than 1000 and summed all the values in it. Then I did the same with
multiples of 5. Then I added them together.

Turns out these two arrays (obviously) had duplicate values.
So I had to shoehorn in a fix using a builtin that I don't understand
particularly well, but which seems to remove all duplicate values from one of
the arrays. This solution produced the correct answer.

This file is full of notes where I try to make sense of things in order to remember them.
Approach these attempts with great skepticism; they are probably bullshit.

*/

var multiplesOf3 = [];
var multiplesOf5 = [];


for (var i = 0; i <= 333; i++) {
  multiplesOf3.push(i * 3);
}


//Generates an array of every multiple of 3 less than 1000.


for (var j = 0; j < 200; j++) {
  if (j * 5)
  multiplesOf5.push(j * 5);
}

//Generates an array of every multiple of 5 less than 1000

multiplesOf3 = multiplesOf3.filter(function(val) {
  return multiplesOf5.indexOf(val) == -1;
});

/* Removes duplicate values from multiplesOf3.

You provide a callback function to .filter(), which is provided once for each
element in the array. If the callback function returns a "truthy" value (Google it),
then that element is included in a new array constructed by .filter(), and if not,
not.

.indexOf() returns the first index at which a given element can be found in an array,
or -1 if it's not present. You provide the element to locate as an argument.

So every non-duplicate element returns -1 to .indexOf(),
and therefore evaluates to "true" when using indexOf as the
callback function for .filter(),
and therefore is included in the new array produced by .filter().

see https://stackoverflow.com/questions/14930516/compare-two-javascript-arrays-and-remove-duplicates
*/

var sumThrees = multiplesOf3.reduce(add, 0);

function add(a, b) {
  return a + b;
}

/* Sums all the elements in the cleaned-up multiplesOf3

.reduce() can take two arguments: a callback function, and optionally an initial value.
It applies the callback against an accumulator and each element in the array from
left to right.

I do not yet know enough words to really get how this works, or even really the
syntax tbh.

See https://stackoverflow.com/questions/1230233/how-to-find-the-sum-of-an-array-of-numbers
*/

var sumFives = multiplesOf5.reduce(addFives, 0);

function addFives(a, b) {
  return a + b;
}

//Sums all elements in multiplesOf5

console.log('Euler 1: The sum of all multiples of 3 and 5 below 1000 is ' + (sumThrees + sumFives));

/*

EULER # 2 PROBLEM: "Each new term in the Fibonacci sequence is generated by adding
the previous two terms. By starting with 1 and 2, the first 10 terms will be:

1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

By considering the terms in the Fibonacci sequence whose values do not exceed
four million, find the sum of the even-valued terms."

NOTES: The algorithm for the Fibonnaci sequence can be written so you're only
keeping track of 3 numbers: two addends and the total.

Add a and b to get c. To get the next number, we add b and c. But if we just
want to continue, we don't need a anymore. So we can reassign a to the new total:

     a + b = c
     b + c = a

Then we have to add c + a, and reassign the total to b:

    c + a = b

We're always adding the last two terms, and reassigning the value of the
first to hold the sum.

So if we start with a = 1 and b = 2, we get:
    c   a   b
    3 = 1 + 2;
    a = 2;
    b = 3;
    5 = 2 + 3;
    a = 3;
    b = 5;
    8 = 3 + 5

So we just need to keep looping over that to get the sequence like this:

    c = a + b;
    a = b;
    b = c;

Next, we just have to:
  (1) determine if each Fibonacci number is even;
  (2) if it is, add it to an accumulator (?) variable; and
  (3) set an upper limit so it doesn't loop forever.

We already know how to do (1) and (3) in a few different ways, although it's
worth noting that for (1), "a" is the only variable that EVERY Fibonnacci number
will cycle through.

For (2), the += operator will be helpful:

   x += y is shorthand for x = x + y

Okay, let's try.
*/

var a = 1;
var b = 2;
var c = 0;
var evenSum = 0;
while ( a <= 4e6) {
  if (a % 2 === 0) {
    evenSum += a;
  }

  c = a + b;
  a = b;
  b = c;
}

console.log('Euler 2: The sum of the even-valued Fibonnacci numbers not greater than 4,000,000 is ' + evenSum);
